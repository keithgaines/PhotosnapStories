"use strict";

var _Object$defineProperty = require("@babel/runtime-corejs3/core-js/object/define-property");
var _interopRequireWildcard = require("@babel/runtime-corejs3/helpers/interopRequireWildcard").default;
var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault").default;
_Object$defineProperty(exports, "__esModule", {
  value: true
});
exports.createCell = createCell;
var _extends2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/extends"));
var _isArray = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/array/is-array"));
var _every = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/every"));
var _values = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/object/values"));
var _globalThis2 = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/global-this"));
var _stringify = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/json/stringify"));
var _react = _interopRequireWildcard(require("react"));
var _graphql = require("../graphql");
var _CellCacheContext = require("./CellCacheContext");
var _GraphQLHooksProvider = require("./GraphQLHooksProvider");
/**
 * This is part of how we let users swap out their GraphQL client while staying compatible with Cells.
 */

/**
 *
 * If the Cell has a `beforeQuery` function, then the variables are not required,
 * but instead the arguments of the `beforeQuery` function are required.
 *
 * If the Cell does not have a `beforeQuery` function, then the variables are required.
 *
 * Note that a query that doesn't take any variables is defined as {[x: string]: never}
 * The ternary at the end makes sure we don't include it, otherwise it won't allow merging any
 * other custom props from the Success component.
 *
 */

/**
 * Cell component props which is the combination of query variables and Success props.
 */

// aka guarantee that all properties in T exist
// This is necessary for Cells, because if it doesn't exist it'll go to Empty or Failure
/**
 * Use this type, if you are forwarding on the data from your Cell's Success component
 * Because Cells automatically checks for "empty", or "errors" - if you receive the data type in your
 * Success component, it means the data is guaranteed (and non-optional)
 *
 * @params TData = Type of data based on your graphql query. This can be imported from 'types/graphql'
 * @example
 * import type {FindPosts} from 'types/graphql'
 *
 * const { post } = CellSuccessData<FindPosts>
 *
 * post.id // post is non optional, so no need to do post?.id
 *
 */
/**
 * @MARK not sure about this partial, but we need to do this for tests and storybook.
 *
 * `updating` is just `loading` renamed; since Cells default to stale-while-refetch,
 * this prop lets users render something like a spinner to show that a request is in-flight.
 */
// pre-computing makes the types more readable on hover
/**
 * A coarse type for the `data` prop returned by `useQuery`.
 *
 * ```js
 * {
 *   data: {
 *     post: { ... }
 *   }
 * }
 * ```
 */
/**
 * The main interface.
 */
/**
 * The default `isEmpty` implementation. Checks if any of the field is `null` or an empty array.
 *
 * Consider the following queries. The former returns an object, the latter a list:
 *
 * ```js
 * export const QUERY = gql`
 *   post {
 *     title
 *   }
 * `
 *
 * export const QUERY = gql`
 *   posts {
 *     title
 *   }
 * `
 * ```
 *
 * If either are "empty", they return:
 *
 * ```js
 * {
 *   data: {
 *     post: null
 *   }
 * }
 *
 * {
 *   data: {
 *     posts: []
 *   }
 * }
 * ```
 *
 * Note that the latter can return `null` as well depending on the SDL (`posts: [Post!]`).
 * ```
 */
function isFieldEmptyArray(field) {
  return (0, _isArray.default)(field) && field.length === 0;
}
function isDataEmpty(data) {
  var _context;
  return (0, _every.default)(_context = (0, _values.default)(data)).call(_context, fieldValue => {
    return fieldValue === null || isFieldEmptyArray(fieldValue);
  });
}

/**
 * Creates a Cell out of a GraphQL query and components that track to its lifecycle.
 */
function createCell(_ref) {
  let {
    QUERY,
    beforeQuery = props => ({
      // By default, we assume that the props are the gql-variables.
      variables: props,
      /**
       * We're duplicating these props here due to a suspected bug in Apollo Client v3.5.4
       * (it doesn't seem to be respecting `defaultOptions` in `RedwoodApolloProvider`.)
       *
       * @see {@link https://github.com/apollographql/apollo-client/issues/9105}
       */
      fetchPolicy: 'cache-and-network',
      notifyOnNetworkStatusChange: true
    }),
    afterQuery = data => ({
      ...data
    }),
    isEmpty = isDataEmpty,
    Loading = () => /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, "Loading..."),
    Failure,
    Empty,
    Success,
    displayName = 'Cell'
  } = _ref;
  function NamedCell(props) {
    /**
     * Right now, Cells don't render `children`.
     */
    const {
      children: _,
      ...variables
    } = props;
    const options = beforeQuery(variables);
    const query = typeof QUERY === 'function' ? QUERY(options) : QUERY;

    // queryRest includes `variables: { ... }`, with any variables returned
    // from beforeQuery
    let {
      // eslint-disable-next-line prefer-const
      error,
      loading,
      data,
      ...queryResult
    } = (0, _GraphQLHooksProvider.useQuery)(query, options);
    if (_globalThis2.default.__REDWOOD__PRERENDERING) {
      // __REDWOOD__PRERENDERING will always either be set, or not set. So
      // rules-of-hooks are still respected, even though we wrap this in an if
      // statement
      /* eslint-disable-next-line react-hooks/rules-of-hooks */
      const {
        queryCache
      } = (0, _CellCacheContext.useCellCacheContext)();
      const operationName = (0, _graphql.getOperationName)(query);
      let cacheKey;
      if (operationName) {
        cacheKey = operationName + '_' + (0, _stringify.default)(variables);
      } else {
        const cellName = displayName === 'Cell' ? 'the cell' : displayName;
        throw new Error(`The gql query in ${cellName} is missing an operation name. ` + 'Something like FindBlogPostQuery in ' + '`query FindBlogPostQuery($id: Int!)`');
      }
      const queryInfo = queryCache[cacheKey];

      // This is true when the graphql handler couldn't be loaded
      // So we fallback to the loading state
      if (queryInfo?.renderLoading) {
        loading = true;
      } else {
        if (queryInfo?.hasProcessed) {
          loading = false;
          data = queryInfo.data;

          // All of the gql client's props aren't available when pre-rendering,
          // so using `any` here
          queryResult = {
            variables
          };
        } else {
          queryCache[cacheKey] || (queryCache[cacheKey] = {
            query,
            variables: options.variables,
            hasProcessed: false
          });
        }
      }
    }
    if (error) {
      if (Failure) {
        var _errorCode;
        // errorCode is not part of the type returned by useQuery
        // but it is returned as part of the queryResult

        return /*#__PURE__*/_react.default.createElement(Failure, (0, _extends2.default)({
          error: error,
          errorCode: // Use the ad-hoc QueryResultWithErrorCode type to access the errorCode
          (_errorCode = queryResult.errorCode) !== null && _errorCode !== void 0 ? _errorCode : error.graphQLErrors?.[0]?.extensions?.['code']
        }, props, {
          updating: loading,
          queryResult: queryResult
        }));
      } else {
        throw error;
      }
    } else if (data) {
      const afterQueryData = afterQuery(data);
      if (isEmpty(data, {
        isDataEmpty
      }) && Empty) {
        return /*#__PURE__*/_react.default.createElement(Empty, (0, _extends2.default)({}, props, afterQueryData, {
          updating: loading,
          queryResult: queryResult
        }));
      } else {
        return /*#__PURE__*/_react.default.createElement(Success, (0, _extends2.default)({}, props, afterQueryData, {
          updating: loading,
          queryResult: queryResult
        }));
      }
    } else if (loading) {
      return /*#__PURE__*/_react.default.createElement(Loading, (0, _extends2.default)({}, props, {
        queryResult: queryResult
      }));
    } else {
      /**
       * There really shouldn't be an `else` here, but like any piece of software, GraphQL clients have bugs.
       * If there's no `error` and there's no `data` and we're not `loading`, something's wrong. Most likely with the cache.
       *
       * @see {@link https://github.com/redwoodjs/redwood/issues/2473#issuecomment-971864604}
       */
      console.warn(`If you're using Apollo Client, check for its debug logs here in the console, which may help explain the error.`);
      throw new Error('Cannot render Cell: reached an unexpected state where the query succeeded but `data` is `null`. If this happened in Storybook, your query could be missing fields; otherwise this is most likely a GraphQL caching bug. Note that adding an `id` field to all the fields on your query may fix the issue.');
    }
  }
  NamedCell.displayName = displayName;
  return props => {
    return (
      /*#__PURE__*/
      // Cells don't suspend, so the fallback won't render. We only use
      // <Suspense> for cell prerender rehydration support
      _react.default.createElement(_react.Suspense, {
        fallback: null
      }, /*#__PURE__*/_react.default.createElement(NamedCell, props))
    );
  };
}
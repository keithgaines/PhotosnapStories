"use strict";

var _Object$defineProperty = require("@babel/runtime-corejs3/core-js/object/define-property");
var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault").default;
_Object$defineProperty(exports, "__esModule", {
  value: true
});
exports.partialMatch = void 0;
var _entries = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/object/entries"));
var _stringify = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/json/stringify"));
var _for = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/symbol/for"));
var _isArray = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/array/is-array"));
var _map = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/map"));
// Custom Jest matchers to be used with Redwood's server caching
// Just needs a global import like import '@redwoodjs/testing/cache'
expect.extend({
  toHaveCached(cacheClient, keyOrExpectedValue, expectedValue) {
    let value;
    let regexKey;
    let stringKey;

    // Figures out which form of this function we're calling:
    // with one or two arguments

    if (_isKVPair(keyOrExpectedValue, expectedValue)) {
      // Two argument form, the key that is caching it and the value that is cached:
      // toHaveCached('cache-key', { foo: 'bar' })
      if (keyOrExpectedValue instanceof RegExp) {
        regexKey = keyOrExpectedValue;
      } else {
        stringKey = keyOrExpectedValue;
      }
      value = expectedValue;
    } else {
      // One argument form, only check the value that's cached:
      //  toHaveCached({ foo: 'bar' })
      value = keyOrExpectedValue;
    }
    let foundKVPair;
    let found = false;

    // If its a stringKey we can do direct lookup
    if (stringKey) {
      return _checkValueForKey(cacheClient, stringKey, value);
    } else {
      // For RegEx expectedKey or just a value check, we need to iterate
      for (const [cachedKey, cachedValue] of (0, _entries.default)(cacheClient.storage)) {
        if (found) {
          break;
        }
        if (regexKey?.test(cachedKey)) {
          found = true;
          foundKVPair = {
            key: cachedKey,
            value: cachedValue.value
          };
        } else {
          // no key was passed, just match on value
          found = cachedValue.value === (0, _stringify.default)(value);
        }
      }
    }

    // Key was supplied as a regex
    // So we check if the value is cached, and return early
    if (foundKVPair) {
      return _checkValueForKey(cacheClient, foundKVPair.key, value);
    }
    if (found) {
      return {
        pass: true,
        message: () => 'Found cached value'
      };
    } else {
      return {
        pass: false,
        message: () => `Expected Cached Value: ${this.utils.printExpected((0, _stringify.default)(value))}\n` + `Cache Contents: ${this.utils.printReceived(cacheClient.storage)}`
      };
    }
  }
});
const _isKVPair = (keyOrCachedValue, cachedValue) => {
  return !!cachedValue && !!keyOrCachedValue;
};
const _checkValueForKey = (cacheClient, cacheKey, expectedValue) => {
  try {
    const cachedStringValue = cacheClient.storage[cacheKey]?.value;

    // Check if its a jest asymmetric matcher i.e. objectContaining, arrayContaining
    const expectedValueOrMatcher = expectedValue?.$$typeof === (0, _for.default)('jest.asymmetricMatcher') ? expectedValue : JSON.parse((0, _stringify.default)(expectedValue)); // Because e.g. dates get converted to string, when cached

    expect(cachedStringValue ? JSON.parse(cachedStringValue) : undefined).toEqual(expectedValueOrMatcher);
    return {
      pass: true,
      message: () => `Found cached value with ${cacheKey}`
    };
  } catch (e) {
    // Return the message from jest's helpers so they get a nice diff
    // and exit early!
    return {
      pass: false,
      message: () => e.message
    };
  }
};
/**
 * This is just syntactic sugar, to help with testing cache contents.
 *
 * If you pass an array, it will check arrays for a partial match of the object.
 *
 * If you pass an object, it will check for a partial match of the object.
 *
 * Useful when you don't want to compare dates/auto-generated ids etc.
 *
 * @example
 * expect(testCacheClient.contents).toContainEqual(partialMatch({ title: 'Only look for this title'}))
 *
 * @example
 * expect(testCacheClient.contents).toContainEqual(partialMatch([{id: 1}, {id: 2}]))
 *
 * @param value Object or Array of object to match
 */
const partialMatch = value => {
  return (0, _isArray.default)(value) ? expect.arrayContaining((0, _map.default)(value).call(value, v => expect.objectContaining(v))) : expect.objectContaining(value);
};
exports.partialMatch = partialMatch;
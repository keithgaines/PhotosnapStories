"use strict";

var _Object$defineProperty = require("@babel/runtime-corejs3/core-js/object/define-property");
var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault").default;
_Object$defineProperty(exports, "__esModule", {
  value: true
});
exports.sendTelemetry = exports.sanitizeArgv = void 0;
require("core-js/modules/es.array.push.js");
var _keys = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/object/keys"));
var _slice = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/slice"));
var _forEach = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/for-each"));
var _indexOf = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/index-of"));
var _includes = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/includes"));
var _findIndex = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/find-index"));
var _map = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/map"));
var _startsWith = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/starts-with"));
var _parseInt2 = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/parse-int"));
var _now = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/date/now"));
var _stringify = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/json/stringify"));
var _fs = _interopRequireDefault(require("fs"));
var _os = _interopRequireDefault(require("os"));
var _path = _interopRequireDefault(require("path"));
var _fetch = require("@whatwg-node/fetch");
var _ciInfo = _interopRequireDefault(require("ci-info"));
var _envinfo = _interopRequireDefault(require("envinfo"));
var _systeminformation = _interopRequireDefault(require("systeminformation"));
var _uuid = require("uuid");
var _projectConfig = require("@redwoodjs/project-config");
// circular dependency when trying to import @redwoodjs/structure so lets do it
// the old fashioned way
const {
  DefaultHost
} = require('@redwoodjs/structure/dist/hosts');
const {
  RWProject
} = require('@redwoodjs/structure/dist/model/RWProject');
// Tracks any commands that could contain sensitive info and their position in
// the argv array, as well as the text to replace them with
const SENSITIVE_ARG_POSITIONS = {
  exec: {
    positions: [1],
    redactWith: ['[script]'],
    allowOnly: ['exec']
  },
  g: {
    positions: [2, 3],
    redactWith: ['[name]', '[path]']
  },
  generate: {
    positions: [2, 3],
    redactWith: ['[name]', '[path]']
  },
  prisma: {
    options: ['--name'],
    redactWith: ['[name]']
  },
  lint: {
    allowOnly: ['lint', '--fix'],
    redactWith: ['[path]']
  }
};
/** Gets diagnostic info and sanitizes by removing references to paths */
const getInfo = async (presets = {}) => {
  const info = JSON.parse(await _envinfo.default.run({
    System: ['OS', 'Shell'],
    Binaries: ['Node', 'Yarn', 'npm'],
    npmPackages: '@redwoodjs/*',
    IDEs: ['VSCode']
  }, {
    json: true
  }));

  // get shell name instead of path
  const shell = info.System?.Shell; // Windows doesn't always provide shell info, I guess
  if (shell?.path?.match('/')) {
    info.System.Shell.name = info.System.Shell.path.split('/').pop();
  } else if (shell?.path.match('\\')) {
    info.System.Shell.name = info.System.Shell.path.split('\\').pop();
  }
  const cpu = await _systeminformation.default.cpu();
  const mem = await _systeminformation.default.mem();

  // Must only call getConfig() once the project is setup - so not within telemetry for CRWA
  // Default to 'webpack' for new projects
  const webBundler = presets.command?.startsWith('create redwood-app') ? 'webpack' : (0, _projectConfig.getConfig)().web.bundler;

  // Returns a list of all enabled experiments
  // This detects all top level [experimental.X] and returns all X's, ignoring all Y's for any [experimental.X.Y]
  const experiments = (0, _keys.default)((0, _projectConfig.getRawConfig)()['experimental'] || {});

  // NOTE: Added this way to avoid the need to disturb the existing toml structure
  if (webBundler !== 'webpack') {
    experiments.push(webBundler);
  }
  return {
    os: info.System?.OS?.split(' ')[0],
    osVersion: info.System?.OS?.split(' ')[1],
    shell: info.System?.Shell?.name,
    nodeVersion: info.Binaries?.Node?.version,
    yarnVersion: info.Binaries?.Yarn?.version,
    npmVersion: info.Binaries?.npm?.version,
    vsCodeVersion: info.IDEs?.VSCode?.version,
    redwoodVersion: presets.redwoodVersion || info.npmPackages['@redwoodjs/core']?.installed,
    system: `${cpu.physicalCores}.${Math.round(mem.total / 1073741824)}`,
    webBundler,
    experiments
  };
};

// removes potentially sensitive information from an array of argv strings
const sanitizeArgv = argv => {
  const name = argv[2];
  const sensitiveCommand = SENSITIVE_ARG_POSITIONS[name];
  const args = (0, _slice.default)(argv).call(argv, 2);
  if (sensitiveCommand) {
    // redact positional arguments
    if (sensitiveCommand.positions) {
      var _context;
      (0, _forEach.default)(_context = sensitiveCommand.positions).call(_context, (pos, index) => {
        // only redact if the text in the given position is not a --flag
        if (args[pos] && !/--/.test(args[pos])) {
          args[pos] = sensitiveCommand.redactWith[index];
        }
      });
    }

    // redact --option arguments
    if (sensitiveCommand.options) {
      var _context2;
      (0, _forEach.default)(_context2 = sensitiveCommand.options).call(_context2, (option, index) => {
        const argIndex = (0, _indexOf.default)(args).call(args, option);
        if (argIndex !== -1) {
          args[argIndex + 1] = sensitiveCommand.redactWith[index];
        }
      });
    }

    // allow only clause
    if (sensitiveCommand.allowOnly) {
      (0, _forEach.default)(args).call(args, (arg, index) => {
        var _context3;
        if (!sensitiveCommand.allowOnly?.includes(arg) && !(0, _includes.default)(_context3 = sensitiveCommand.redactWith).call(_context3, arg)) {
          args[index] = sensitiveCommand.redactWith[0];
        }
      });
    }
  }
  return args.join(' ');
};
exports.sanitizeArgv = sanitizeArgv;
const buildPayload = async () => {
  let payload = {};
  let project;
  const processArgv = [...process.argv];

  // On windows process.argv may not return an array of strings.
  // It will look something like [a,b,c] rather than ["a","b","c"] so we must stringify them before parsing as JSON
  // "os.type()" returns 'Windows_NT' on Windows. See https://nodejs.org/docs/latest-v12.x/api/os.html#os_os_type.
  if (_os.default.type() === 'Windows_NT') {
    const argvIndex = (0, _findIndex.default)(processArgv).call(processArgv, arg => arg === '--argv') + 1;
    let argvFormatted = argvIndex !== 0 ? processArgv[argvIndex] : null;
    if (argvFormatted) {
      var _context4;
      argvFormatted = '[' + (0, _map.default)(_context4 = argvFormatted.substring(1, argvFormatted.length - 1).split(',')).call(_context4, arg => {
        return (0, _startsWith.default)(arg).call(arg, '"') || (0, _startsWith.default)(arg).call(arg, "'") ? arg : `"${arg}"`;
      }).join(',') + ']';
      processArgv[argvIndex] = argvFormatted;
    }
  }
  const argv = require('yargs/yargs')((0, _slice.default)(processArgv).call(processArgv, 2)).parse();
  const rootDir = argv.root;
  const command = argv.argv ? sanitizeArgv(JSON.parse(argv.argv)) : '';
  payload = {
    type: argv.type || 'command',
    command,
    duration: argv.duration ? (0, _parseInt2.default)(argv.duration) : null,
    uid: uniqueId(rootDir) || null,
    ci: _ciInfo.default.isCI,
    redwoodCi: !!process.env.REDWOOD_CI,
    NODE_ENV: process.env.NODE_ENV || null,
    ...(await getInfo({
      redwoodVersion: argv.rwVersion,
      command
    }))
  };
  if (argv.error) {
    payload.type = 'error';
    payload.error = argv.error.split('\n')[0].replace(/(\/[@\-\.\w]+)/g, '[path]');
  }

  // if a root directory was specified, use that to look up framework stats
  // with the `structure` package
  if (rootDir) {
    project = new RWProject({
      projectRoot: rootDir,
      host: new DefaultHost()
    });
  }

  // add in app stats
  payload = {
    ...payload,
    complexity: `${project.getRouter().routes.length}.${project.services.length}.${project.cells.length}.${project.pages.length}`,
    sides: project.sides.join(',')
  };
  return payload;
};

// returns the UUID for this device. caches the UUID for 24 hours
const uniqueId = rootDir => {
  const telemetryCachePath = _path.default.join(rootDir || '/tmp', '.redwood', 'telemetry.txt');
  const now = (0, _now.default)();
  const expires = now - 24 * 60 * 60 * 1000; // one day
  let uuid;
  if (!_fs.default.existsSync(telemetryCachePath) || _fs.default.statSync(telemetryCachePath).mtimeMs < expires) {
    uuid = (0, _uuid.v4)();
    try {
      // Create `.redwood` directory if it does not exist
      if (!_fs.default.existsSync(_path.default.dirname(telemetryCachePath))) {
        _fs.default.mkdirSync(_path.default.dirname(telemetryCachePath), {
          recursive: true
        });
      }
      _fs.default.writeFileSync(telemetryCachePath, uuid);
    } catch (error) {
      console.error('\nCould not create telemetry.txt file\n');
    }
  } else {
    uuid = _fs.default.readFileSync(telemetryCachePath).toString();
  }
  return uuid;
};

// actually call the API with telemetry data
const sendTelemetry = async () => {
  const telemetryUrl = process.env.REDWOOD_REDIRECT_TELEMETRY || 'https://telemetry.redwoodjs.com/api/v1/telemetry';
  try {
    const payload = await buildPayload();
    if (process.env.REDWOOD_VERBOSE_TELEMETRY) {
      console.info('Redwood Telemetry Payload', payload);
    }
    const response = await (0, _fetch.fetch)(telemetryUrl, {
      method: 'post',
      body: (0, _stringify.default)(payload),
      headers: {
        'Content-Type': 'application/json'
      }
    });
    if (process.env.REDWOOD_VERBOSE_TELEMETRY) {
      console.info('Redwood Telemetry Response:', response);
    }

    // Normally we would report on any non-error response here (like a 500)
    // but since the process is spawned and stdout/stderr is ignored, it can
    // never be seen by the user, so ignore.
    if (process.env.REDWOOD_VERBOSE_TELEMETRY && response.status !== 200) {
      console.error('Error from telemetry insert:', await response.text());
    }
  } catch (e) {
    // service interruption: network down or telemetry API not responding
    // don't let telemetry errors bubble up to user, just do nothing.
    if (process.env.REDWOOD_VERBOSE_TELEMETRY) {
      console.error('Uncaught error in telemetry:', e);
    }
  }
};
exports.sendTelemetry = sendTelemetry;
"use strict";

var _Object$defineProperty = require("@babel/runtime-corejs3/core-js/object/define-property");
var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault").default;
_Object$defineProperty(exports, "__esModule", {
  value: true
});
exports.createGraphQLHandler = void 0;
require("core-js/modules/es.array.push.js");
var _map = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/map"));
var _url = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/url"));
var _forEach = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/for-each"));
var _stringify = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/json/stringify"));
var _map2 = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/map"));
var _disableIntrospection = require("@envelop/disable-introspection");
var _filterOperationType = require("@envelop/filter-operation-type");
var _graphql = require("graphql");
var _graphqlYoga = require("graphql-yoga");
var _cors = require("../cors");
var _makeDirectives = require("../directives/makeDirectives");
var _globalContext = require("../globalContext");
var _makeMergedSchema = require("../makeMergedSchema/makeMergedSchema");
var _plugins = require("../plugins");
/* eslint-disable react-hooks/rules-of-hooks */

/**
 * Creates an Enveloped GraphQL Server, configured with default Redwood plugins
 *
 * You can add your own plugins by passing them to the extraPlugins object
 *
 * @see https://www.envelop.dev/ for information about envelop
 * @see https://www.envelop.dev/plugins for available envelop plugins
 * ```js
 * export const handler = createGraphQLHandler({ schema, context, getCurrentUser })
 * ```
 */
const createGraphQLHandler = ({
  healthCheckId,
  loggerConfig,
  context,
  getCurrentUser,
  onException,
  generateGraphiQLHeader,
  extraPlugins,
  authDecoder,
  cors,
  services,
  sdls,
  directives = [],
  armorConfig,
  allowedOperations,
  allowIntrospection,
  defaultError = 'Something went wrong.',
  graphiQLEndpoint = '/graphql',
  schemaOptions
}) => {
  let schema;
  let redwoodDirectivePlugins = [];
  const logger = loggerConfig.logger;
  try {
    // @NOTE: Directives are optional
    const projectDirectives = (0, _makeDirectives.makeDirectivesForPlugin)(directives);
    if (projectDirectives.length > 0) {
      ;
      redwoodDirectivePlugins = (0, _map.default)(projectDirectives).call(projectDirectives, directive => (0, _plugins.useRedwoodDirective)(directive));
    }
    schema = (0, _makeMergedSchema.makeMergedSchema)({
      sdls,
      services,
      directives: projectDirectives,
      schemaOptions
    });
  } catch (e) {
    logger.fatal(e, '\n ⚠️ GraphQL server crashed \n');

    // Forcefully crash the graphql server
    // so users know that a misconfiguration has happened
    process.exit(1);
  }

  // Important: Plugins are executed in order of their usage, and inject functionality serially,
  // so the order here matters
  const isDevEnv = process.env.NODE_ENV === 'development';
  const plugins = [];
  if (allowIntrospection == null && !isDevEnv || allowIntrospection === false) {
    plugins.push((0, _disableIntrospection.useDisableIntrospection)());
  }

  // Custom Redwood plugins
  plugins.push((0, _plugins.useRedwoodAuthContext)(getCurrentUser, authDecoder));
  plugins.push((0, _plugins.useRedwoodGlobalContextSetter)());
  if (context) {
    plugins.push((0, _plugins.useRedwoodPopulateContext)(context));
  }

  // Custom Redwood plugins
  plugins.push(...redwoodDirectivePlugins);

  // Custom Redwood OpenTelemetry plugin
  plugins.push((0, _plugins.useRedwoodOpenTelemetry)());

  // Secure the GraphQL server
  plugins.push((0, _plugins.useArmor)(logger, armorConfig));

  // Only allow execution of specific operation types
  plugins.push((0, _filterOperationType.useFilterAllowedOperations)(allowedOperations || [_graphql.OperationTypeNode.QUERY, _graphql.OperationTypeNode.MUTATION]));

  // App-defined plugins
  if (extraPlugins && extraPlugins.length > 0) {
    plugins.push(...extraPlugins);
  }
  plugins.push((0, _plugins.useRedwoodError)(logger));
  plugins.push((0, _graphqlYoga.useReadinessCheck)({
    endpoint: graphiQLEndpoint + '/readiness',
    check: async ({
      request
    }) => {
      try {
        // if we can reach the health check endpoint ...
        const response = await yoga.fetch(new _url.default(graphiQLEndpoint + '/health', request.url));
        const expectedHealthCheckId = healthCheckId || 'yoga';

        // ... and the health check id's match the request and response's
        const status = response.headers.get('x-yoga-id') === expectedHealthCheckId && request.headers.get('x-yoga-id') === expectedHealthCheckId;

        // then we're good to go (or not)
        return status;
      } catch (err) {
        logger.error(err);
        return false;
      }
    }
  }));

  // Must be "last" in plugin chain, but before error masking
  // so can process any data added to results and extensions
  plugins.push((0, _plugins.useRedwoodLogger)(loggerConfig));
  const yoga = (0, _graphqlYoga.createYoga)({
    id: healthCheckId,
    landingPage: isDevEnv,
    schema,
    plugins,
    maskedErrors: {
      errorMessage: defaultError,
      isDev: isDevEnv
    },
    logging: logger,
    healthCheckEndpoint: graphiQLEndpoint + '/health',
    graphqlEndpoint: graphiQLEndpoint,
    graphiql: isDevEnv ? {
      title: 'Redwood GraphQL Playground',
      headers: generateGraphiQLHeader ? generateGraphiQLHeader() : `{"x-auth-comment": "See documentation: https://redwoodjs.com/docs/cli-commands#setup-graphiQL-headers on how to auto generate auth headers"}`,
      defaultQuery: `query Redwood {
  redwood {
    version
  }
}`,
      headerEditorEnabled: true
    } : false,
    cors: request => {
      const requestOrigin = request.headers.get('origin');
      return (0, _cors.mapRwCorsOptionsToYoga)(cors, requestOrigin);
    }
  });
  const handlerFn = async (event, requestContext) => {
    // In the future, this could be part of a specific handler for AWS lambdas
    requestContext.callbackWaitsForEmptyEventLoop = false;
    let lambdaResponse;
    try {
      var _context;
      // url needs to be normalized
      const [, rest = ''] = event.path.split(graphiQLEndpoint);
      const url = new _url.default(graphiQLEndpoint + rest, 'http://localhost');
      if (event.queryStringParameters != null) {
        for (const queryName in event.queryStringParameters) {
          const queryValue = event.queryStringParameters[queryName];
          if (queryValue != null) {
            url.searchParams.set(queryName, queryValue);
          }
        }
      }
      const response = await yoga.fetch(url, {
        method: event.httpMethod,
        headers: event.headers,
        body: event.body ? Buffer.from(event.body, event.isBase64Encoded ? 'base64' : 'utf8') : undefined
      }, {
        event,
        requestContext
      });

      // @WARN - multivalue headers aren't supported on all deployment targets correctly
      // Netlify ✅, Vercel 🛑, AWS ✅,...
      // From https://docs.aws.amazon.com/apigateway/latest/developerguide/set-up-lambda-proxy-integrations.html#api-gateway-simple-proxy-for-lambda-input-format
      // If you specify values for both headers and multiValueHeaders, API Gateway merges them into a single list.
      const responseHeaders = {};
      (0, _forEach.default)(_context = response.headers).call(_context, (value, name) => {
        responseHeaders[name] = value;
      });
      lambdaResponse = {
        body: await response.text(),
        statusCode: response.status,
        headers: responseHeaders,
        isBase64Encoded: false
      };
    } catch (e) {
      logger.error(e);
      onException && onException();
      lambdaResponse = {
        body: (0, _stringify.default)({
          error: 'GraphQL execution failed'
        }),
        statusCode: 200 // should be 500
      };
    }

    if (!lambdaResponse.headers) {
      lambdaResponse.headers = {};
    }

    /**
     * The header keys are case insensitive, but Fastify prefers these to be lowercase.
     * Therefore, we want to ensure that the headers are always lowercase and unique
     * for compliance with HTTP/2.
     *
     * @see: https://www.rfc-editor.org/rfc/rfc7540#section-8.1.2
     */
    // DT: Yoga v3 uses `application/graphql-response+json; charset=utf-8`
    // But we still do want to make sure the header is lowercase.
    // Comment out for now since GraphiQL doesn't work with this header anymore
    // because it loads its UI from a CDN and needs text/html to be the response type
    // lambdaResponse.headers['content-type'] = 'application/json'
    return lambdaResponse;
  };
  return (event, context) => {
    const execFn = async () => {
      try {
        return await handlerFn(event, context);
      } catch (e) {
        onException && onException();
        throw e;
      }
    };
    if ((0, _globalContext.getAsyncStoreInstance)()) {
      // This must be used when you're self-hosting RedwoodJS.
      return (0, _globalContext.getAsyncStoreInstance)().run(new _map2.default(), execFn);
    } else {
      // This is OK for AWS (Netlify/Vercel) because each Lambda request
      // is handled individually.
      return execFn();
    }
  };
};
exports.createGraphQLHandler = createGraphQLHandler;
"use strict";

var _Object$defineProperty = require("@babel/runtime-corejs3/core-js/object/define-property");
var _interopRequireWildcard = require("@babel/runtime-corejs3/helpers/interopRequireWildcard").default;
var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault").default;
_Object$defineProperty(exports, "__esModule", {
  value: true
});
exports.useRedwoodOpenTelemetry = exports.AttributeName = void 0;
var _stringify = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/json/stringify"));
var _core = require("@envelop/core");
var _onResolve = require("@envelop/on-resolve");
var opentelemetry = _interopRequireWildcard(require("@opentelemetry/api"));
var _graphql = require("graphql");
let AttributeName = /*#__PURE__*/function (AttributeName) {
  AttributeName["EXECUTION_ERROR"] = "graphql.execute.error";
  AttributeName["EXECUTION_RESULT"] = "graphql.execute.result";
  AttributeName["RESOLVER_EXCEPTION"] = "graphql.resolver.exception";
  AttributeName["RESOLVER_FIELD_NAME"] = "graphql.resolver.fieldName";
  AttributeName["RESOLVER_TYPE_NAME"] = "graphql.resolver.typeName";
  AttributeName["RESOLVER_RESULT_TYPE"] = "graphql.resolver.resultType";
  AttributeName["RESOLVER_ARGS"] = "graphql.resolver.args";
  AttributeName["EXECUTION_OPERATION_NAME"] = "graphql.execute.operationName";
  AttributeName["EXECUTION_OPERATION_DOCUMENT"] = "graphql.execute.document";
  AttributeName["EXECUTION_VARIABLES"] = "graphql.execute.variables";
  return AttributeName;
}({}); // const tracingSpanSymbol = Symbol('OPEN_TELEMETRY_GRAPHQL')
exports.AttributeName = AttributeName;
const tracingSpanSymbol = 'OPEN_TELEMETRY_GRAPHQL';
const useRedwoodOpenTelemetry = () => {
  const spanKind = opentelemetry.SpanKind.SERVER;
  const spanAdditionalAttributes = {};
  const options = {
    resolvers: true,
    result: true,
    variables: true
  };
  const tracer = opentelemetry.trace.getTracer('redwoodjs');
  return {
    onPluginInit({
      addPlugin
    }) {
      if (options.resolvers) {
        addPlugin((0, _onResolve.useOnResolve)(({
          info,
          context,
          args
        }) => {
          if (context && typeof context === 'object' && context[tracingSpanSymbol]) {
            const ctx = opentelemetry.trace.setSpan(opentelemetry.context.active(), context[tracingSpanSymbol]);
            const {
              fieldName,
              returnType,
              parentType
            } = info;
            const resolverSpan = tracer.startSpan(`${parentType.name}.${fieldName}`, {
              attributes: {
                [AttributeName.RESOLVER_FIELD_NAME]: fieldName,
                [AttributeName.RESOLVER_TYPE_NAME]: parentType.toString(),
                [AttributeName.RESOLVER_RESULT_TYPE]: returnType.toString(),
                [AttributeName.RESOLVER_ARGS]: (0, _stringify.default)(args || {})
              }
            }, ctx);
            return ({
              result
            }) => {
              if (result instanceof Error) {
                resolverSpan.recordException({
                  name: AttributeName.RESOLVER_EXCEPTION,
                  message: (0, _stringify.default)(result)
                });
              }
              resolverSpan.end();
            };
          }
          return () => {};
        }));
      }
    },
    onExecute({
      args,
      extendContext
    }) {
      const executionSpan = tracer.startSpan(`${args.operationName || 'Anonymous Operation'}`, {
        kind: spanKind,
        attributes: {
          ...spanAdditionalAttributes,
          [AttributeName.EXECUTION_OPERATION_NAME]: args.operationName ?? undefined,
          [AttributeName.EXECUTION_OPERATION_DOCUMENT]: (0, _graphql.print)(args.document),
          ...(options.variables ? {
            [AttributeName.EXECUTION_VARIABLES]: (0, _stringify.default)(args.variableValues ?? {})
          } : {})
        }
      });
      const resultCbs = {
        onExecuteDone({
          result
        }) {
          if ((0, _core.isAsyncIterable)(result)) {
            executionSpan.end();
            // eslint-disable-next-line no-console
            console.warn(`Plugin "newrelic" encountered a AsyncIterator which is not supported yet, so tracing data is not available for the operation.`);
            return;
          }
          if (result.data && options.result) {
            executionSpan.setAttribute(AttributeName.EXECUTION_RESULT, (0, _stringify.default)(result));
          }
          if (result.errors && result.errors.length > 0) {
            executionSpan.recordException({
              name: AttributeName.EXECUTION_ERROR,
              message: (0, _stringify.default)(result.errors)
            });
          }
          executionSpan.end();
        }
      };
      if (options.resolvers) {
        extendContext({
          [tracingSpanSymbol]: executionSpan
        });
      }
      return resultCbs;
    }
  };
};
exports.useRedwoodOpenTelemetry = useRedwoodOpenTelemetry;
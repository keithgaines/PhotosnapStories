"use strict";

var _Object$defineProperty = require("@babel/runtime-corejs3/core-js/object/define-property");
var _interopRequireWildcard = require("@babel/runtime-corejs3/helpers/interopRequireWildcard").default;
var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault").default;
_Object$defineProperty(exports, "__esModule", {
  value: true
});
exports.writeFilesTask = exports.writeFile = exports.transformTSToJS = exports.prettify = exports.prettierOptions = void 0;
var _map = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/map"));
var _keys = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/object/keys"));
var _fs = _interopRequireDefault(require("fs"));
var _path = _interopRequireDefault(require("path"));
var babel = _interopRequireWildcard(require("@babel/core"));
var _listr = require("listr2");
var _prettier = require("prettier");
var _colors = require("./colors");
var _paths = require("./paths");
// TODO: Move this into `generateTemplate` when all templates have TS support
/*
 * Convert a generated TS template file into JS.
 */
const transformTSToJS = (filename, content) => {
  if (!content) {
    return content;
  }
  const babelFileResult = babel.transform(content, {
    filename,
    // If you ran `yarn rw generate` in `./web` transformSync would import the `.babelrc.js` file,
    // in `./web`? despite us setting `configFile: false`.
    cwd: process.env.NODE_ENV === 'test' ? undefined : (0, _paths.getPaths)().base,
    configFile: false,
    plugins: [['@babel/plugin-transform-typescript', {
      isTSX: true,
      allExtensions: true
    }]],
    retainLines: true
  });
  if (!babelFileResult?.code) {
    console.error(_colors.colors.error(`Could not transform ${filename} to JS`));
    process.exit(1);
  }
  return prettify(filename.replace(/\.tsx?$/, '.js'), babelFileResult.code);
};

/**
 * This returns the config present in `prettier.config.js` of a Redwood project.
 */
exports.transformTSToJS = transformTSToJS;
const prettierOptions = () => {
  try {
    return require(_path.default.join((0, _paths.getPaths)().base, 'prettier.config.js'));
  } catch (e) {
    return undefined;
  }
};
exports.prettierOptions = prettierOptions;
const prettify = (templateFilename, renderedTemplate) => {
  // We format .js and .css templates, we need to tell prettier which parser
  // we're using.
  // https://prettier.io/docs/en/options.html#parser
  const parser = {
    '.css': 'css',
    '.js': 'babel',
    '.ts': 'babel-ts',
    '.tsx': 'babel-ts'
  }[_path.default.extname(templateFilename.replace('.template', ''))];
  if (typeof parser === 'undefined') {
    return renderedTemplate;
  }
  return (0, _prettier.format)(renderedTemplate, {
    ...prettierOptions(),
    parser
  });
};
exports.prettify = prettify;
const writeFile = (target, contents, {
  existingFiles = 'FAIL'
} = {},
// TODO: Remove type cast
task = {}) => {
  const {
    base
  } = (0, _paths.getPaths)();
  task.title = `Writing \`./${_path.default.relative(base, target)}\``;
  const exists = _fs.default.existsSync(target);
  if (exists && existingFiles === 'FAIL') {
    throw new Error(`${target} already exists.`);
  }
  if (exists && existingFiles === 'SKIP') {
    task.skip();
    return;
  }
  const filename = _path.default.basename(target);
  const targetDir = target.replace(filename, '');
  _fs.default.mkdirSync(targetDir, {
    recursive: true
  });
  _fs.default.writeFileSync(target, contents);
  task.title = `Successfully wrote file \`./${_path.default.relative(base, target)}\``;
};

/**
 * Creates a list of tasks that write files to the disk.
 *
 * @param files - {[filepath]: contents}
 */
exports.writeFile = writeFile;
const writeFilesTask = (files, options) => {
  var _context;
  const {
    base
  } = (0, _paths.getPaths)();
  return new _listr.Listr((0, _map.default)(_context = (0, _keys.default)(files)).call(_context, file => {
    const contents = files[file];
    return {
      title: `...waiting to write file \`./${_path.default.relative(base, file)}\`...`,
      task: (_ctx, task) => {
        return writeFile(file, contents, options, task);
      }
    };
  }));
};
exports.writeFilesTask = writeFilesTask;
"use strict";

var _Object$defineProperty = require("@babel/runtime-corejs3/core-js/object/define-property");
var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault").default;
_Object$defineProperty(exports, "__esModule", {
  value: true
});
exports.standardAuthHandler = exports.standardAuthBuilder = void 0;
require("core-js/modules/es.array.push.js");
var _filter = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/filter"));
var _listr = require("listr2");
var _terminalLink = _interopRequireDefault(require("terminal-link"));
var _telemetry = require("@redwoodjs/telemetry");
var _colors = require("../lib/colors");
var _installHelpers = require("../lib/installHelpers");
var _authTasks = require("./authTasks");
const standardAuthBuilder = yargs => {
  return yargs.option('force', {
    alias: 'f',
    default: false,
    description: 'Overwrite existing auth configuration',
    type: 'boolean'
  }).option('verbose', {
    alias: 'v',
    default: false,
    description: 'Log setup output',
    type: 'boolean'
  }).epilogue(`Also see the ${(0, _terminalLink.default)('Redwood CLI Reference', 'https://redwoodjs.com/docs/cli-commands#setup-auth')}`);
};

// from lodash
exports.standardAuthBuilder = standardAuthBuilder;
function truthy(value) {
  return !!value;
}

/**
 *  basedir assumes that you must have a templates folder in that directory.
 *  See folder structure of auth providers in packages/auth-providers/<provider>/setup/src
 */
const standardAuthHandler = async ({
  basedir,
  forceArg,
  provider,
  authDecoderImport,
  webAuthn = false,
  webPackages = [],
  apiPackages = [],
  extraTask,
  notes,
  verbose
}) => {
  var _context;
  // @TODO detect if auth already setup. If it is, ask how to proceed:
  // How would you like to proceed?
  // 1. Replace existing auth provider with <provider>
  // 2. Combine providers ~~ NOT SUPPORTED YET ~~

  const tasks = new _listr.Listr((0, _filter.default)(_context = [(0, _authTasks.setAuthSetupMode)(forceArg), (0, _authTasks.generateAuthApiFiles)(basedir, webAuthn), (0, _authTasks.addConfigToWebApp)(), (0, _authTasks.createWebAuth)(basedir, webAuthn), (0, _authTasks.addConfigToRoutes)(), (0, _authTasks.addAuthConfigToGqlApi)(authDecoderImport), webPackages.length && (0, _installHelpers.addWebPackages)(webPackages), apiPackages.length && (0, _installHelpers.addApiPackages)(apiPackages), (webPackages.length || apiPackages.length) && _installHelpers.installPackages, extraTask, notes && {
    title: 'One more thing...',
    task: ctx => {
      // Can't console.log the notes here because of
      // https://github.com/cenk1cenk2/listr2/issues/296
      // So we do it after the tasks have all finished instead
      if (ctx.setupMode === 'REPLACE') {
        notes.push(...['', `${_colors.colors.warning('Your existing auth provider has been replaced!')}`, "You'll still need to manually remove your old auth provider's config,", "functions, and dependencies (in your web and api package.json's)."]);
      }
      if (ctx.setupMode === 'COMBINE') {
        notes.push(_colors.colors.warning("To avoid overwriting existing files we've generated new file " + 'names for the newly generated files. This probably means ' + `${ctx.provider} auth doesn't work out of the box. You'll most ` + 'likely have to manually merge some of the generated files ' + 'with your existing auth files'));
      }
    }
  }]).call(_context, truthy), {
    rendererOptions: {
      collapseSubtasks: false
    },
    renderer: verbose ? 'verbose' : 'default',
    ctx: {
      setupMode: 'UNKNOWN',
      provider // provider name passed from CLI
    }
  });

  try {
    await tasks.run();
    notes && console.log(`\n   ${notes.join('\n   ')}\n`);
  } catch (e) {
    if (isErrorWithMessage(e)) {
      (0, _telemetry.errorTelemetry)(process.argv, e.message);
      console.error(_colors.colors.error(e.message));
    }
    if (isErrorWithErrorCode(e)) {
      process.exit(e.exitCode || 1);
    } else {
      process.exit(1);
    }
  }
};
exports.standardAuthHandler = standardAuthHandler;
function isErrorWithMessage(e) {
  return !!e.message;
}
function isErrorWithErrorCode(e) {
  return !isNaN(e.exitCode);
}
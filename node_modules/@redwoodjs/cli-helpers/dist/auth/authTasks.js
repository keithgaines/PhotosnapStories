"use strict";

var _Object$defineProperty = require("@babel/runtime-corejs3/core-js/object/define-property");
var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault").default;
_Object$defineProperty(exports, "__esModule", {
  value: true
});
exports.setAuthSetupMode = exports.removeAuthProvider = exports.hasAuthProvider = exports.getWebAppPath = exports.generateAuthApiFiles = exports.createWebAuth = exports.addConfigToWebApp = exports.addConfigToRoutes = exports.addAuthConfigToGqlApi = exports.addApiConfig = void 0;
require("core-js/modules/es.array.push.js");
var _includes = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/includes"));
var _splice = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/splice"));
var _reduce = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/reduce"));
var _at = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/at"));
var _trimEnd = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/trim-end"));
var _map = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/map"));
var _find = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/find"));
var _startsWith = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/starts-with"));
var _filter = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/filter"));
var _keys = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/object/keys"));
var _fs = _interopRequireDefault(require("fs"));
var _path = _interopRequireDefault(require("path"));
var _lib = require("../lib");
var _colors = require("../lib/colors");
var _paths = require("../lib/paths");
var _project = require("../lib/project");
var _authFiles = require("./authFiles");
const AUTH_PROVIDER_HOOK_IMPORT = `import { AuthProvider, useAuth } from './auth'`;
const AUTH_HOOK_IMPORT = `import { useAuth } from './auth'`;
const getWebAppPath = () => (0, _paths.getPaths)().web.app;

/**
 * This function looks for the createGraphQLHandler function call and adds
 * `authDecoder` to its arguments if it's not already there. Almost always it
 * will not be there, but if the user already has an auth provider set up and
 * wants to add another one it's probably there, and in that case we don't
 * want to add another one
 *
 * @param content - The contents of api/src/functions/graphql.ts
 * @returns content with `authDecoder` added unless it was already there
 */
exports.getWebAppPath = getWebAppPath;
function addAuthDecoderToCreateGraphQLHandler(content) {
  // Have to use a funky looking Regex here to prevent a "Polynomial regular
  // expression used on uncontrolled data" warning/error. A.k.a "Catastrophic
  // Backtracking". The usual fix is to use an atomic group, but the JS
  // regex engine doesn't support that, so we use a lookaround group to
  // emulate an atomic group.
  if (!new RegExp('(?=(^.*?createGraphQLHandler))\\1.*\\bauthDecoder', 's').test(content)) {
    return content.replace(/^(?<indentation>\s*)(loggerConfig:)(.*)$/m, `$<indentation>authDecoder,\n$<indentation>$2$3`);
  }
  return content;
}

/**
 * Replace the existing `import { authDecoder } from 'x'` with a new one
 *
 * @param content - The contents of api/src/functions/graphql.ts
 * @param decoderImport - Something like
 *   `import { authDecoder } from '@redwoodjs/auth-clerk-api'`
 * @returns content with the authDecoder import replaced with the new import
 */
function replaceAuthDecoderImport(content, decoderImport) {
  return content.replace(/^import { authDecoder .*} from .+/, decoderImport);
}

/**
 * Replace the existing `  authDecoder: myAuthDecoder,` with a standard
 * `  authDecoder,`
 *
 * @param content - The contents of api/src/functions/graphql.ts
 * @returns content with standard authDecoder arg to createGraphQLHandler
 */
function replaceAuthDecoderArg(content) {
  return content.replace(/^(\s+)authDecoder\b.+/m, '$1authDecoder,');
}

// Exporting this to make it easier to test
const addApiConfig = ({
  replaceExistingImport,
  authDecoderImport
}) => {
  const graphqlPath = (0, _project.getGraphqlPath)();
  if (!graphqlPath) {
    throw new Error('Could not find your graphql file path');
  }
  const content = _fs.default.readFileSync(graphqlPath).toString();
  let newContent = content;
  if (authDecoderImport) {
    if (replaceExistingImport) {
      newContent = replaceAuthDecoderImport(newContent, authDecoderImport);
      newContent = replaceAuthDecoderArg(newContent);
    }
    const didReplace = (0, _includes.default)(newContent).call(newContent, authDecoderImport);

    // If we asked to replace existing code, but didn't actually replace
    // anything we should just add it. That's why we do `|| !didReplace` here
    if (!replaceExistingImport || !didReplace) {
      newContent = authDecoderImport + '\n' + newContent;
      newContent = addAuthDecoderToCreateGraphQLHandler(newContent);
    }
  }
  const hasCurrentUserImport = /(^import {.*?getCurrentUser(?!getCurrentUser).*?} from 'src\/lib\/auth')/s.test(newContent);
  if (!hasCurrentUserImport) {
    // add import statement
    newContent = newContent.replace(/^(import { db } from 'src\/lib\/db')$/m, `import { getCurrentUser } from 'src/lib/auth'\n$1`);

    // add object to handler
    newContent = newContent.replace(/^(\s*)(loggerConfig:)(.*)$/m, `$1getCurrentUser,\n$1$2$3`);
  }
  if (newContent !== content) {
    _fs.default.writeFileSync(graphqlPath, newContent);
  }
};
exports.addApiConfig = addApiConfig;
const apiSrcDoesExist = () => {
  return _fs.default.existsSync(_path.default.join((0, _paths.getPaths)().api.src));
};
const addAuthImportToApp = content => {
  const contentLines = content.split('\n');
  // Find the last import line that's not a .css or .scss import
  const importIndex = contentLines.findLastIndex(line => /^\s*import (?!.*(?:.css'|.scss'))/.test(line));

  // After the import found above, insert a blank line followed by the
  // AuthProvider and useAuth import
  (0, _splice.default)(contentLines).call(contentLines, importIndex + 1, 0, '', AUTH_PROVIDER_HOOK_IMPORT);
  return contentLines.join('\n');
};
const addAuthImportToRoutes = content => {
  const contentLines = content.split('\n');
  // Find the last import line that's not a .css or .scss import
  const importIndex = contentLines.findLastIndex(line => /^\s*import (?!.*(?:.css'|.scss'))/.test(line));

  // After the import found above, insert a blank line followed by the
  // useAuth import
  (0, _splice.default)(contentLines).call(contentLines, importIndex + 1, 0, '', AUTH_HOOK_IMPORT);
  return contentLines.join('\n');
};

// exported for testing
const hasAuthProvider = content => {
  return /\s*<AuthProvider([\s>]|$)/.test(content);
};

/**
 * Removes <AuthProvider ...> and </AuthProvider> if they exist, and un-indents
 * the content.
 *
 * Exported for testing
 */
exports.hasAuthProvider = hasAuthProvider;
const removeAuthProvider = content => {
  var _context;
  let remove = false;
  let end = '';
  let unindent = false;
  return (0, _reduce.default)(_context = content.split('\n')).call(_context, (acc, line) => {
    var _context2;
    let keep = !remove;
    // Find where <AuthProvider begins and remove until it ends (to handle
    // multi-line auth providers)
    if (hasAuthProvider(line)) {
      remove = true;
      keep = false;
      unindent = true;
      // Assume the end line is indented to the same level as the start,
      // and contains just a single '>'
      end = line.replace(/^(\s*)<Auth.*/s, '$1') + '>';
    }

    // Single-line AuthProvider, or end of multi-line
    // .trimEnd() to handle CRLF
    if (hasAuthProvider(line) && (0, _at.default)(_context2 = (0, _trimEnd.default)(line).call(line)).call(_context2, -1) === '>' || (0, _trimEnd.default)(line).call(line) === end) {
      remove = false;
    }
    if (/\s*<\/AuthProvider>/.test(line)) {
      keep = false;
      unindent = false;
    }
    if (keep) {
      if (unindent) {
        acc.push(line.replace('  ', ''));
      } else {
        acc.push(line);
      }
    }
    return acc;
  }, []).join('\n');
};

/** returns the content of App.{js,tsx} with <AuthProvider> added */
exports.removeAuthProvider = removeAuthProvider;
const addAuthProviderToApp = (content, setupMode) => {
  var _context3;
  if (setupMode === 'FORCE' || setupMode === 'REPLACE') {
    content = removeAuthProvider(content);
  }
  const match = content.match(/(\s+)(<RedwoodProvider.*?>)(.*)(<\/RedwoodProvider>)/s);
  if (!match) {
    throw new Error('Could not find <RedwoodProvider> in App.{js,tsx}');
  }

  // If Auth.tsx already contains exactly what we're trying to add there's no
  // need to add it (important that this check is performed after the FORCE ||
  // REPLACE check is made above)
  if (/\s+<AuthProvider>/.test(content)) {
    return content;
  }
  const [_, newlineAndIndent, redwoodProviderOpen, redwoodProviderChildren, redwoodProviderClose] = match;
  const redwoodProviderChildrenLines = (0, _map.default)(_context3 = redwoodProviderChildren.split('\n')).call(_context3, (line, index) => {
    return `${index === 0 ? '' : '  '}` + line;
  });
  const renderContent = newlineAndIndent + redwoodProviderOpen + newlineAndIndent + '  ' + `<AuthProvider>` + redwoodProviderChildrenLines.join('\n') + `</AuthProvider>` + newlineAndIndent + redwoodProviderClose;
  return content.replace(/\s+<RedwoodProvider.*?>.*<\/RedwoodProvider>/s, renderContent);
};
const hasUseAuthHook = (componentName, content) => {
  return new RegExp(`<${componentName}.*useAuth={.*?}.*?>.*<\/${componentName}>`, 's').test(content);
};
const addUseAuthHook = (componentName, content) => {
  return content.replace(`<${componentName}`, `<${componentName} useAuth={useAuth}`);
};

/**
 * Actually inserts the required config lines into App.{js,tsx}
 * Exported for testing
 */
const addConfigToWebApp = () => {
  return {
    title: 'Updating web/src/App.{js,tsx}',
    task: (ctx, task) => {
      const webAppPath = getWebAppPath();
      if (!_fs.default.existsSync(webAppPath)) {
        const ext = (0, _project.isTypeScriptProject)() ? 'tsx' : 'js';
        throw new Error(`Could not find root App.${ext}`);
      }
      let content = _fs.default.readFileSync(webAppPath, 'utf-8');
      if (!(0, _includes.default)(content).call(content, AUTH_PROVIDER_HOOK_IMPORT)) {
        content = addAuthImportToApp(content);
      }
      if (ctx.setupMode === 'REPLACE' || ctx.setupMode === 'FORCE') {
        // Remove legacy AuthProvider import
        content = content.replace("import { AuthProvider } from '@redwoodjs/auth'\n", '');
      }
      content = addAuthProviderToApp(content, ctx.setupMode);
      if (/\s*<RedwoodApolloProvider/.test(content)) {
        if (!hasUseAuthHook('RedwoodApolloProvider', content)) {
          content = addUseAuthHook('RedwoodApolloProvider', content);
        }
      } else {
        task.output = _colors.colors.warning('Could not find <RedwoodApolloProvider>.\nIf you are using a custom ' + 'GraphQL Client you will have to make sure it gets access to your ' + '`useAuth`, if it needs it.');
      }
      _fs.default.writeFileSync(webAppPath, content);
    }
  };
};
exports.addConfigToWebApp = addConfigToWebApp;
const createWebAuth = (basedir, webAuthn) => {
  var _context4;
  const templatesBaseDir = _path.default.join(basedir, 'templates', 'web');
  const templates = _fs.default.readdirSync(templatesBaseDir);
  const templateFileName = (0, _find.default)(templates).call(templates, template => {
    return (0, _startsWith.default)(template).call(template, 'auth.' + (webAuthn ? 'webAuthn.ts' : 'ts'));
  });
  if (!templateFileName) {
    throw new Error('Could not find the auth.ts template');
  }
  const templateExtension = (0, _at.default)(_context4 = templateFileName.split('.')).call(_context4, -2);
  const isTSProject = (0, _project.isTypeScriptProject)();

  // ext will be tsx, ts or js
  const ext = (0, _project.isTypeScriptProject)() ? templateExtension : 'js';
  return {
    title: `Creating web/src/auth.${ext}`,
    task: ctx => {
      // @MARK - finding unused file name here,
      // We should only use an unused filename, if the user is CHOOSING not to replace the existing provider

      // Find an unused filename
      // Start with web/src/auth.{ts,tsx}
      // Then web/src/providerAuth.{ts,tsx}
      // Then web/src/providerAuth2.{ts,tsx}
      // Then web/src/providerAuth3.{ts,tsx}
      // etc

      let authFileName = _path.default.join((0, _paths.getPaths)().web.src, 'auth');

      // Generate a unique name, when you are trying to combine providers
      if (ctx.setupMode === 'COMBINE') {
        let i = 1;
        while ((0, _paths.resolveFile)(authFileName)) {
          const count = i > 1 ? i : '';
          authFileName = _path.default.join((0, _paths.getPaths)().web.src, ctx.provider + 'Auth' + count);
          i++;
        }
      }
      authFileName = authFileName + '.' + ext;
      let template = _fs.default.readFileSync(_path.default.join(templatesBaseDir, templateFileName), 'utf-8');
      template = isTSProject ? template : (0, _lib.transformTSToJS)(authFileName, template);
      _fs.default.writeFileSync(authFileName, template);
    }
  };
};
exports.createWebAuth = createWebAuth;
const addConfigToRoutes = () => {
  return {
    title: 'Updating Routes file...',
    task: () => {
      const webRoutesPath = (0, _paths.getPaths)().web.routes;
      let content = _fs.default.readFileSync(webRoutesPath).toString();
      if (!(0, _includes.default)(content).call(content, AUTH_HOOK_IMPORT)) {
        content = addAuthImportToRoutes(content);
      }
      if (!hasUseAuthHook('Router', content)) {
        content = addUseAuthHook('Router', content);
      }
      _fs.default.writeFileSync(webRoutesPath, content);
    }
  };
};

/**
 * Will find the templates inside `${basedir}/templates/api`,
 * and write these files to disk with unique names if they are clashing.
 *
 * @returns Listr task
 */
exports.addConfigToRoutes = addConfigToRoutes;
const generateAuthApiFiles = (basedir, webAuthn) => {
  return {
    title: 'Generating auth api side files...',
    task: async (ctx, task) => {
      if (!apiSrcDoesExist()) {
        return new Error('Could not find api/src directory. Cannot continue setup!');
      }

      // The keys in `filesRecord` are the full paths to where the file contents,
      // which is the values in `filesRecord`, will be written.
      let filesRecord = (0, _authFiles.apiSideFiles)({
        basedir,
        webAuthn
      });

      // Always overwrite files in force mode, no need to prompt
      let existingFiles = 'FAIL';
      if (ctx.setupMode === 'FORCE') {
        existingFiles = 'OVERWRITE';
      } else if (ctx.setupMode === 'REPLACE') {
        // Confirm that we're about to overwrite some files
        const filesToOverwrite = findExistingFiles(filesRecord);
        const overwrite = await task.prompt({
          type: 'confirm',
          message: `Overwrite existing ${filesToOverwrite.join(', ')}?`,
          initial: false
        });
        existingFiles = overwrite ? 'OVERWRITE' : 'SKIP';
      } else if (ctx.setupMode === 'COMBINE') {
        const uniqueFilesRecord = (0, _authFiles.generateUniqueFileNames)(filesRecord, ctx.provider);
        filesRecord = uniqueFilesRecord;

        // Shouldn't happen because we've just generated unique file names
        existingFiles = 'FAIL';
      }
      return (0, _lib.writeFilesTask)(filesRecord, {
        existingFiles
      });
    }
  };
};
/**
 * Returns a map of file names (not full paths) that already exist
 */
exports.generateAuthApiFiles = generateAuthApiFiles;
function findExistingFiles(filesMap) {
  var _context5, _context6;
  return (0, _map.default)(_context5 = (0, _filter.default)(_context6 = (0, _keys.default)(filesMap)).call(_context6, filePath => _fs.default.existsSync(filePath))).call(_context5, filePath => filePath.replace((0, _paths.getPaths)().base, ''));
}
const addAuthConfigToGqlApi = authDecoderImport => ({
  title: 'Adding auth config to GraphQL API...',
  task: (ctx, _task) => {
    if ((0, _project.graphFunctionDoesExist)()) {
      addApiConfig({
        authDecoderImport,
        replaceExistingImport: ctx.setupMode === 'REPLACE' || ctx.setupMode === 'FORCE'
      });
    } else {
      throw new Error('GraphQL function not found. You will need to pass the decoder to the createGraphQLHandler function.');
    }
  }
});

// we will prompt the user to select a mode
exports.addAuthConfigToGqlApi = addAuthConfigToGqlApi;
const setAuthSetupMode = force => {
  return {
    title: 'Checking project for existing auth...',
    task: async (ctx, task) => {
      if (force) {
        ctx.setupMode = 'FORCE';
        return;
      }
      const webAppContents = _fs.default.readFileSync(getWebAppPath(), 'utf-8');

      // If we don't know whether the user wants to replace or combine,
      // we prompt them to select a mode.
      if (hasAuthProvider(webAppContents) && ctx.setupMode === 'UNKNOWN') {
        // const setupMode = await task.prompt<AuthSetupMode>({
        //   type: 'select',
        //   message: `Looks like you have an auth provider already setup. How would you like to proceed?`,
        //   choices: [
        //     {
        //       message: `Replace existing auth with ${ctx.provider}`,
        //       value: 'REPLACE', // this is the value
        //     },
        //     {
        //       message: `Generate files, setup manually. [ADVANCED]`,
        //       value: 'COMBINE', // this is the value
        //       disabled: true,
        //     },
        //   ],
        // })
        // TODO: Enable code above, and remove this hardcoded value when we
        // have COMBINE working
        const setupMode = 'REPLACE';

        // User has selected the setup mode, so we set it on the context
        // This is used in the tasks downstream
        ctx.setupMode = setupMode;
        return;
      } else {
        ctx.setupMode = 'FORCE';
        task.skip('Setting up Auth from scratch');
      }
    }
  };
};
exports.setAuthSetupMode = setAuthSetupMode;
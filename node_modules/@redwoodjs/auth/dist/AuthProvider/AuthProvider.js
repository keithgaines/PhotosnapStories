"use strict";

var _Object$defineProperty = require("@babel/runtime-corejs3/core-js/object/define-property");
var _interopRequireWildcard = require("@babel/runtime-corejs3/helpers/interopRequireWildcard").default;
_Object$defineProperty(exports, "__esModule", {
  value: true
});
exports.createAuthProvider = createAuthProvider;
var _react = _interopRequireWildcard(require("react"));
var _AuthProviderState = require("./AuthProviderState");
var _useCurrentUser = require("./useCurrentUser");
var _useForgotPassword = require("./useForgotPassword");
var _useHasRole = require("./useHasRole");
var _useLogIn = require("./useLogIn");
var _useLogOut = require("./useLogOut");
var _useReauthenticate = require("./useReauthenticate");
var _useResetPassword = require("./useResetPassword");
var _useSignUp = require("./useSignUp");
var _useToken = require("./useToken");
var _useValidateResetToken = require("./useValidateResetToken");
function createAuthProvider(AuthContext, authImplementation, customProviderHooks) {
  const AuthProvider = _ref => {
    let {
      children,
      skipFetchCurrentUser
    } = _ref;
    // const [hasRestoredState, setHasRestoredState] = useState(false)

    const [authProviderState, setAuthProviderState] = (0, _react.useState)(_AuthProviderState.defaultAuthProviderState);
    const getToken = (0, _useToken.useToken)(authImplementation);

    // We're disabling eslint here, because while yes, technically we are
    // conditionally calling a hook, which you're not allowed to do. But in
    // practice a customProviderHook is either always going to be supplied,
    // or never
    const getCurrentUser = customProviderHooks?.useCurrentUser ? customProviderHooks.useCurrentUser :
    // eslint-disable-next-line react-hooks/rules-of-hooks
    (0, _useCurrentUser.useCurrentUser)(authImplementation);
    const reauthenticate = (0, _useReauthenticate.useReauthenticate)(authImplementation, setAuthProviderState, getCurrentUser, skipFetchCurrentUser);
    const hasRole = customProviderHooks?.useHasRole ? customProviderHooks.useHasRole(authProviderState.currentUser) :
    // eslint-disable-next-line react-hooks/rules-of-hooks
    (0, _useHasRole.useHasRole)(authProviderState.currentUser);
    const signUp = (0, _useSignUp.useSignUp)(authImplementation, setAuthProviderState, getCurrentUser, skipFetchCurrentUser);
    const logIn = (0, _useLogIn.useLogIn)(authImplementation, setAuthProviderState, getCurrentUser, skipFetchCurrentUser);
    const logOut = (0, _useLogOut.useLogOut)(authImplementation, setAuthProviderState);
    const forgotPassword = (0, _useForgotPassword.useForgotPassword)(authImplementation);
    const resetPassword = (0, _useResetPassword.useResetPassword)(authImplementation);
    const validateResetToken = (0, _useValidateResetToken.useValidateResetToken)(authImplementation);
    const type = authImplementation.type;
    const client = authImplementation.client;

    // Whenever the authImplementation is ready to go, restore auth and reauthenticate
    (0, _react.useEffect)(() => {
      async function doRestoreState() {
        await authImplementation.restoreAuthState?.();
        reauthenticate();
      }
      doRestoreState();
    }, [reauthenticate]);
    return /*#__PURE__*/_react.default.createElement(AuthContext.Provider, {
      value: {
        ...authProviderState,
        signUp,
        logIn,
        logOut,
        getToken,
        getCurrentUser,
        hasRole,
        reauthenticate,
        forgotPassword,
        resetPassword,
        validateResetToken,
        client,
        type
      }
    }, children);
  };
  return AuthProvider;
}
"use strict";

var _Object$defineProperty = require("@babel/runtime-corejs3/core-js/object/define-property");
var _interopRequireWildcard = require("@babel/runtime-corejs3/helpers/interopRequireWildcard").default;
var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault").default;
_Object$defineProperty(exports, "__esModule", {
  value: true
});
exports.Private = Private;
exports.Set = Set;
var _extends2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/extends"));
var _isArray = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/array/is-array"));
var _globalThis2 = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/global-this"));
var _reduceRight = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/reduce-right"));
var _react = _interopRequireWildcard(require("react"));
var _links = require("./links");
var _PageLoadingContext = require("./PageLoadingContext");
var _router = require("./router");
var _routerContext = require("./router-context");
const IdentityWrapper = _ref => {
  let {
    children
  } = _ref;
  return /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, children);
};

/**
 * TypeScript will often infer the type of the props you can forward to the
 * wrappers for you, but if you need to you can specify it yourself in your
 * JSX like so:
 *   <Set<{theme: string}> wrap={ThemeableLayout} theme="dark">
 */
function Set(props) {
  const {
    wrap,
    children,
    private: privateSet,
    unauthenticated,
    roles,
    whileLoadingAuth,
    whileLoadingPage,
    ...rest
  } = props;
  const routerState = (0, _routerContext.useRouterState)();
  const {
    loading: authLoading,
    isAuthenticated,
    hasRole
  } = routerState.useAuth();
  const {
    loading: pageLoading
  } = (0, _PageLoadingContext.usePageLoadingContext)();
  const unauthorized = (0, _react.useCallback)(() => {
    return !(isAuthenticated && (!roles || hasRole(roles)));
  }, [isAuthenticated, roles, hasRole]);

  // Make sure `wrappers` is always an array with at least one wrapper component
  const wrappers = (0, _isArray.default)(wrap) ? wrap : [wrap ? wrap : IdentityWrapper];
  if (privateSet && unauthorized()) {
    if (!unauthenticated) {
      throw new Error('Private Sets need to specify what route to redirect unauthorized ' + 'users to by setting the `unauthenticated` prop');
    }
    if (authLoading) {
      return whileLoadingAuth?.() || null;
    } else {
      const currentLocation = _globalThis2.default.location.pathname + encodeURIComponent(_globalThis2.default.location.search);
      if (!_router.routes[unauthenticated]) {
        throw new Error(`We could not find a route named ${unauthenticated}`);
      }
      let unauthenticatedPath;
      try {
        unauthenticatedPath = _router.routes[unauthenticated]();
      } catch (e) {
        if (e instanceof Error && /Missing parameter .* for route/.test(e.message)) {
          throw new Error(`Redirecting to route "${unauthenticated}" would require route ` + 'parameters, which currently is not supported. Please choose ' + 'a different route');
        }
        throw new Error(`Could not redirect to the route named ${unauthenticated}`);
      }
      return /*#__PURE__*/_react.default.createElement(_links.Redirect, {
        to: `${unauthenticatedPath}?redirectTo=${currentLocation}`
      });
    }
  }
  const baseChildren = pageLoading && whileLoadingPage ? whileLoadingPage() : children;

  // Expand and nest the wrapped elements.
  return (0, _reduceRight.default)(wrappers).call(wrappers, (acc, wrapper) => {
    return /*#__PURE__*/_react.default.createElement(wrapper, {
      ...rest,
      children: acc ? acc : baseChildren
    });
  }, undefined) || null;
}
function Private(props) {
  const {
    children,
    unauthenticated,
    roles,
    wrap,
    ...rest
  } = props;
  return (
    /*#__PURE__*/
    // @MARK Doesn't matter that we pass `any` here because users still get a
    // typed Private component.
    // If we leave `<any>` out, TS will infer the generic argument to be
    // `WrapperProps`, which looks more correct, but it will cause a type
    // error I'm not sure how to solve
    _react.default.createElement(Set, (0, _extends2.default)({
      private: true,
      unauthenticated: unauthenticated,
      roles: roles,
      wrap: wrap
    }, rest), children)
  );
}
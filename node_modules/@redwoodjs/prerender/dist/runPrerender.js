"use strict";

var _Object$defineProperty = require("@babel/runtime-corejs3/core-js/object/define-property");
var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault").default;
_Object$defineProperty(exports, "__esModule", {
  value: true
});
exports.writePrerenderedHtmlFile = exports.runPrerender = void 0;
var _interopRequireWildcard2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/interopRequireWildcard"));
require("core-js/modules/es.array.push.js");
var _promise = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/promise"));
var _map = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/map"));
var _entries = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/object/entries"));
var _stringify = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/json/stringify"));
var _some = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/some"));
var _values = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/object/values"));
var _find = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/find"));
var _forEach = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/for-each"));
var _endsWith = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/ends-with"));
var _indexOf = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/index-of"));
var _slice = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/slice"));
var _lastIndexOf = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/last-index-of"));
var _globalThis2 = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/global-this"));
var _fs = _interopRequireDefault(require("fs"));
var _path = _interopRequireDefault(require("path"));
var _react = _interopRequireDefault(require("react"));
var _cheerio = require("cheerio");
var _server = _interopRequireDefault(require("react-dom/server"));
var _api = require("@redwoodjs/internal/dist/build/babel/api");
var _web = require("@redwoodjs/internal/dist/build/babel/web");
var _projectConfig = require("@redwoodjs/project-config");
var _router = require("@redwoodjs/router");
var _util = require("@redwoodjs/router/dist/util");
var _babelPluginRedwoodPrerenderMediaImports = _interopRequireDefault(require("./babelPlugins/babel-plugin-redwood-prerender-media-imports"));
var _detection = require("./detection");
var _errors = require("./errors");
var _graphql = require("./graphql/graphql");
var _internal = require("./internal");
async function recursivelyRender(App, renderPath, gqlHandler, queryCache) {
  var _context, _context2;
  // Load this async, to prevent rwjs/web being loaded before shims
  const {
    CellCacheContextProvider,
    getOperationName
  } = require('@redwoodjs/web');
  let shouldShowGraphqlHandlerNotFoundWarn = false;
  // Execute all gql queries we haven't already fetched
  await _promise.default.all((0, _map.default)(_context = (0, _entries.default)(queryCache)).call(_context, async ([cacheKey, value]) => {
    if (value.hasProcessed) {
      // Already fetched, or decided that we can't render this one; skip it!
      return _promise.default.resolve('');
    }
    try {
      const resultString = await (0, _graphql.executeQuery)(gqlHandler, value.query, value.variables);
      let result;
      try {
        result = JSON.parse(resultString);
      } catch (e) {
        if (e instanceof SyntaxError) {
          throw new _errors.JSONParseError({
            query: value.query,
            variables: value.variables,
            result: resultString
          });
        }
      }
      if (result.errors) {
        const message = result.errors[0].message ?? (0, _stringify.default)(result.errors, null, 4);
        if (result.errors[0]?.extensions?.code === 'UNAUTHENTICATED') {
          console.error(`\n \n 🛑  Cannot prerender the query ${getOperationName(value.query)} as it requires auth. \n`);
        }
        throw new _errors.PrerenderGqlError(message);
      }
      queryCache[cacheKey] = {
        ...value,
        data: result.data,
        hasProcessed: true
      };
      return result;
    } catch (e) {
      if (e instanceof _errors.GqlHandlerImportError) {
        // We need to need to swallow the error here, so that
        // we can continue to render the page, with cells in loading state
        // e.g. if the GQL handler is located elsewhere
        shouldShowGraphqlHandlerNotFoundWarn = true;
        queryCache[cacheKey] = {
          ...value,
          // tried to fetch, but failed
          renderLoading: true,
          hasProcessed: true
        };
        return;
      } else {
        // Otherwise forward on the error
        throw e;
      }
    }
  }));
  const componentAsHtml = _server.default.renderToString( /*#__PURE__*/_react.default.createElement(_router.LocationProvider, {
    location: {
      pathname: renderPath
    }
  }, /*#__PURE__*/_react.default.createElement(CellCacheContextProvider, {
    queryCache: queryCache
  }, /*#__PURE__*/_react.default.createElement(App, null))));
  if ((0, _some.default)(_context2 = (0, _values.default)(queryCache)).call(_context2, value => !value.hasProcessed)) {
    // We found new queries that we haven't fetched yet. Execute all new
    // queries and render again
    return recursivelyRender(App, renderPath, gqlHandler, queryCache);
  } else {
    if (shouldShowGraphqlHandlerNotFoundWarn) {
      console.warn('\n  ⚠️  Could not load your GraphQL handler. \n Your Cells have been prerendered in the "Loading" state. \n');
    }
    return _promise.default.resolve(componentAsHtml);
  }
}
function insertChunkLoadingScript(indexHtmlTree, renderPath, vite) {
  const prerenderRoutes = (0, _detection.detectPrerenderRoutes)();
  const route = (0, _find.default)(prerenderRoutes).call(prerenderRoutes, route => {
    return (0, _util.matchPath)(route.routePath, renderPath).match;
  });
  if (!route) {
    throw new Error('Could not find a Route matching ' + renderPath);
  }
  if (!route.pageIdentifier) {
    throw new Error(`Route for ${renderPath} has no pageIdentifier`);
  }
  const buildManifest = JSON.parse(_fs.default.readFileSync(_path.default.join((0, _projectConfig.getPaths)().web.dist, 'build-manifest.json'), 'utf-8'));
  const chunkPaths = [];
  if (!vite) {
    // Webpack

    const pageChunkPath = buildManifest[`${route?.pageIdentifier}.js`];
    if (pageChunkPath) {
      chunkPaths.push(pageChunkPath);
      const chunkReferencesJson = JSON.parse(_fs.default.readFileSync(_path.default.join((0, _projectConfig.getPaths)().web.dist, 'chunk-references.json'), 'utf-8'));
      const chunkReferences = (0, _find.default)(chunkReferencesJson).call(chunkReferencesJson, chunkRef => {
        return chunkRef.name === route?.pageIdentifier;
      });
      if (chunkReferences?.referencedChunks) {
        var _context3;
        (0, _forEach.default)(_context3 = chunkReferences.referencedChunks).call(_context3, chunkId => {
          const chunkRef = (0, _find.default)(chunkReferencesJson).call(chunkReferencesJson, chunkRef => {
            return chunkRef.id === chunkId;
          });

          // Some chunks also produces css files, and maybe other files as well
          // We're only interested in the .js files
          const chunkRefJsFiles = chunkRef?.files.filter(file => {
            return (0, _endsWith.default)(file).call(file, '.js');
          }) || [];
          (0, _forEach.default)(chunkRefJsFiles).call(chunkRefJsFiles, file => {
            chunkPaths.push(file);
          });
          const chunkPath = buildManifest[`${chunkId}.js`];
          if (chunkPath) {
            chunkPaths.push(chunkPath);
          }
        });
      }
    }
  } else if (vite && route?.filePath) {
    var _context4, _context5;
    // TODO: Make sure this works on Windows
    const pagesIndex = (0, _indexOf.default)(_context4 = route.filePath).call(_context4, 'web/src/pages') + 8;
    const pagePath = (0, _slice.default)(_context5 = route.filePath).call(_context5, pagesIndex);
    const pageChunkPath = buildManifest[pagePath]?.file;
    if (pageChunkPath) {
      // The / is needed, otherwise the path is relative to the current page
      // so for example prerendering /userExamples/new wouldn't work
      chunkPaths.push('/' + pageChunkPath);
    }
  }
  if (chunkPaths.length === 0) {
    // This happens when the page is manually imported in Routes.tsx
    // (as opposed to being auto-imported)
    // It also happens for the page at '/' with Webpack
    // It could also be that Webpack or Vite for some reason didn't create a
    // chunk for this page. In that case it'd be nice to throw an error, but
    // there's no easy way to differentiate between the two cases.
    return;
  }
  (0, _forEach.default)(chunkPaths).call(chunkPaths, chunkPath => {
    indexHtmlTree('head').prepend(`<script defer="defer" src="${chunkPath}" ${vite ? 'type="module"' : ''}></script>`);
  });
  if (!vite) {
    return;
  }

  // This is not needed for WebPack

  (0, _forEach.default)(chunkPaths).call(chunkPaths, chunkPath => {
    const fullChunkPath = _path.default.join((0, _projectConfig.getPaths)().web.dist, chunkPath);
    const jsChunk = _fs.default.readFileSync(fullChunkPath, 'utf-8');

    // The chunk will end with something like this: ,{});export{y as default};
    // We need to extract the variable name (y) so that we can expose it on
    // `globalThis` as `<PageName>Page`
    const matches = jsChunk.match(/export\s*\{\s*\w+ as default\s*\}/g) || [];
    const lastIndex = (0, _lastIndexOf.default)(jsChunk).call(jsChunk, matches[matches.length - 1]);
    const varNameMatch = (0, _slice.default)(jsChunk).call(jsChunk, lastIndex).match(/export\s*\{\s*(\w+) as default\s*\}/);
    _fs.default.writeFileSync(fullChunkPath, jsChunk + 'globalThis.__REDWOOD__PRERENDER_PAGES = globalThis.__REDWOOD__PRERENDER_PAGES || {};\n' + `globalThis.__REDWOOD__PRERENDER_PAGES.${route?.pageIdentifier}=${varNameMatch?.[1]};\n`);
  });
}
const runPrerender = async ({
  queryCache,
  renderPath
}) => {
  (0, _internal.registerShims)(renderPath);
  // registerApiSideBabelHook already includes the default api side babel
  // config. So what we define here is additions to the default config
  (0, _api.registerApiSideBabelHook)({
    plugins: [['babel-plugin-module-resolver', {
      alias: {
        api: (0, _projectConfig.getPaths)().api.base,
        web: (0, _projectConfig.getPaths)().web.base
      },
      loglevel: 'silent' // to silence the unnecessary warnings
    }]],

    overrides: [{
      test: ['./api/'],
      plugins: [['babel-plugin-module-resolver', {
        alias: {
          src: (0, _projectConfig.getPaths)().api.src
        },
        loglevel: 'silent'
      }, 'exec-api-src-module-resolver']]
    }]
  });
  const gqlHandler = await (0, _graphql.getGqlHandler)();
  const vite = (0, _projectConfig.getConfig)().web.bundler === 'vite';

  // Prerender specific configuration
  // extends projects web/babelConfig
  (0, _web.registerWebSideBabelHook)({
    forVite: vite,
    overrides: [{
      plugins: [['ignore-html-and-css-imports'],
      // webpack/postcss handles CSS imports
      [_babelPluginRedwoodPrerenderMediaImports.default]]
    }]
  });
  const indexContent = _fs.default.readFileSync((0, _internal.getRootHtmlPath)()).toString();
  const {
    default: App
  } = await (specifier => new _promise.default(r => r(`${specifier}`)).then(s => (0, _interopRequireWildcard2.default)(require(s))))((0, _projectConfig.getPaths)().web.app);
  const componentAsHtml = await recursivelyRender(App, renderPath, gqlHandler, queryCache);
  const {
    helmet
  } = _globalThis2.default.__REDWOOD__HELMET_CONTEXT;
  const indexHtmlTree = (0, _cheerio.load)(indexContent);
  if (helmet) {
    const helmetElements = `
  ${helmet?.link.toString()}
  ${helmet?.meta.toString()}
  ${helmet?.script.toString()}
  ${helmet?.noscript.toString()}
  `;

    // Add all head elements
    indexHtmlTree('head').prepend(helmetElements);
    const titleHtmlTag = helmet.title.toString(); // toString from helmet returns HTML, not the same as cherrio!

    // 1. Check if title is set in the helmet context first...
    if ((0, _cheerio.load)(titleHtmlTag)('title').text() !== '') {
      // 2. Check if html already had a title
      if (indexHtmlTree('title').text().length === 0) {
        // If no title defined in the index.html
        indexHtmlTree('head').prepend(titleHtmlTag);
      } else {
        indexHtmlTree('title').replaceWith(titleHtmlTag);
      }
    }
  }
  insertChunkLoadingScript(indexHtmlTree, renderPath, vite);
  indexHtmlTree('#redwood-app').append(componentAsHtml);
  const renderOutput = indexHtmlTree.html();
  return renderOutput;
};

// Used by cli at build time
exports.runPrerender = runPrerender;
const writePrerenderedHtmlFile = (outputHtmlPath, content) => {
  const outputHtmlAbsPath = _path.default.join((0, _projectConfig.getPaths)().base, outputHtmlPath);
  // Copy default (unprerendered) index.html to 200.html first
  // This is to prevent recursively rendering the home page
  if (outputHtmlPath === 'web/dist/index.html') {
    const html200Path = _path.default.join((0, _projectConfig.getPaths)().web.dist, '200.html');
    if (!_fs.default.existsSync(html200Path)) {
      _fs.default.copyFileSync(outputHtmlAbsPath, html200Path);
    }
  }
  (0, _internal.writeToDist)(outputHtmlAbsPath, content);
};
exports.writePrerenderedHtmlFile = writePrerenderedHtmlFile;
"use strict";

var _Object$defineProperty = require("@babel/runtime-corejs3/core-js/object/define-property");
var _interopRequireWildcard = require("@babel/runtime-corejs3/helpers/interopRequireWildcard").default;
var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault").default;
_Object$defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
require("core-js/modules/es.array.push.js");
var _filter = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/filter"));
var _some = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/some"));
var _indexOf = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/index-of"));
var nodejsPath = _interopRequireWildcard(require("path"));
var _projectConfig = require("@redwoodjs/project-config");
// This wraps user code within opentelemetry spans to provide greater ease in trace analysis.

function _default({
  types: t
}) {
  return {
    name: 'babel-plugin-redwood-otel-wrapping',
    visitor: {
      Program(path) {
        var _context;
        // Only import if it isn't already imported in the way we need it
        // TODO: Check for ImportNamespaceSpecifier like "import * as opentelemetry from '@opentelemetry/api'"
        // TODO: Consider just checking for the import name "opentelemetry" and don't consider the source
        const importDeclarations = (0, _filter.default)(_context = path.node.body).call(_context, node => node.type === 'ImportDeclaration');
        const requiredOpenTelemetryImportExists = (0, _some.default)(importDeclarations).call(importDeclarations, importDeclaration => {
          if (importDeclaration.source.value !== '@opentelemetry/api') {
            return false;
          }
          if (importDeclaration.specifiers[0].type !== 'ImportDefaultSpecifier') {
            return false;
          }
          if (importDeclaration.specifiers[0].local.name === 'opentelemetry') {
            return true;
          }
          return false;
        });
        if (!requiredOpenTelemetryImportExists) {
          path.node.body.unshift(t.importDeclaration([t.importDefaultSpecifier(t.identifier('opentelemetry'))], t.stringLiteral('@opentelemetry/api')));
        }
      },
      ExportNamedDeclaration(path, state) {
        var _context2;
        if (path.node.declaration?.type === 'VariableDeclaration' && path.node.declaration.declarations[0].init?.type === 'ArrowFunctionExpression') {
          var _context3;
          const originalFunc = path.node.declaration.declarations[0].init;
          const originalFuncId = path.node.declaration.declarations[0].id.type === 'Identifier' ? path.node.declaration.declarations[0].id.name : '?';
          const originalFuncArguments = [];
          for (const param of originalFunc.params) {
            switch (param.type) {
              case 'ArrayPattern':
                // TODO: Implement me
                break;
              case 'AssignmentPattern':
                // TODO: Implement me
                break;
              case 'Identifier':
                originalFuncArguments.push(param);
                // TODO: Implement me
                break;
              case 'ObjectPattern':
                // TODO: Is this correct?
                originalFuncArguments.push(t.objectExpression((0, _filter.default)(_context2 = param.properties).call(_context2, p => p.type === 'ObjectProperty')));
                break;
              case 'RestElement':
                // TODO: Implement me
                break;
            }
          }
          const filename = state.file.opts.filename;
          const filenameOffset = filename ? (0, _projectConfig.getBaseDirFromFile)(filename).length + 9 // 9 is the length of '/api/src/'
          : 0;
          const apiFolder = filename ? filename.substring(filenameOffset, (0, _indexOf.default)(_context3 = filename.substring(filenameOffset)).call(_context3, nodejsPath.sep) + filenameOffset) : '?';
          const activeSpanBlock = t.callExpression(t.memberExpression(t.identifier('tracer'), t.identifier('startActiveSpan')), [t.stringLiteral(`redwoodjs:api:${apiFolder}:${originalFuncId}`), t.arrowFunctionExpression([t.identifier('span')], t.blockStatement([t.tryStatement(t.blockStatement([t.variableDeclaration('const', [t.variableDeclarator(t.identifier('innerResult'), originalFunc.async ? t.awaitExpression(t.callExpression(t.identifier(`_${originalFuncId}`), originalFuncArguments)) : t.callExpression(t.identifier(`_${originalFuncId}`), originalFuncArguments))]), t.expressionStatement(t.callExpression(t.memberExpression(t.identifier('span'), t.identifier('setAttribute')), [t.stringLiteral('code.function'), t.stringLiteral(originalFuncId)])), t.expressionStatement(t.callExpression(t.memberExpression(t.identifier('span'), t.identifier('setAttribute')), [t.stringLiteral('code.filepath'), t.stringLiteral(state.file.opts.filename || '?')])), t.expressionStatement(t.callExpression(t.memberExpression(t.identifier('span'), t.identifier('end')), [])), t.returnStatement(t.identifier('innerResult'))]), t.catchClause(t.identifier('error'), t.blockStatement([t.expressionStatement(t.callExpression(t.memberExpression(t.identifier('span'), t.identifier('recordException')), [t.identifier('error')])), t.expressionStatement(t.callExpression(t.memberExpression(t.identifier('span'), t.identifier('end')), [])), t.throwStatement(t.identifier('error'))])))]), originalFunc.async)]);
          const wrapper = t.arrowFunctionExpression(originalFunc.params, t.blockStatement([t.variableDeclaration('const', [t.variableDeclarator(t.identifier(`_${originalFuncId}`), originalFunc)]), t.variableDeclaration('const', [t.variableDeclarator(t.identifier('tracer'), t.callExpression(t.memberExpression(t.memberExpression(t.identifier('opentelemetry'), t.identifier('trace')), t.identifier('getTracer')), [t.stringLiteral('redwoodjs')]))]), t.variableDeclaration('const', [t.variableDeclarator(t.identifier('result'), originalFunc.async ? t.awaitExpression(activeSpanBlock) : activeSpanBlock)]), t.returnStatement(t.identifier('result'))], originalFunc.body.type === 'BlockStatement' ? originalFunc.body.directives : undefined), originalFunc.async);
          path.node.declaration.declarations[0].init = wrapper;
        }
      }
    }
  };
}
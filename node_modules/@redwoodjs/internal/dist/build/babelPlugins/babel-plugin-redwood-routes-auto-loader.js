"use strict";

var _Object$defineProperty = require("@babel/runtime-corejs3/core-js/object/define-property");
var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault").default;
_Object$defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
require("core-js/modules/es.array.push.js");
var _map = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/map"));
var _filter = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/filter"));
var _find = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/find"));
var _path = _interopRequireDefault(require("path"));
var _projectConfig = require("@redwoodjs/project-config");
/**
 * When running from the CLI: Babel-plugin-module-resolver will convert
 * For dev/build/prerender (forJest == false): 'src/pages/ExamplePage' -> './pages/ExamplePage'
 * For test (forJest == true): 'src/pages/ExamplePage' -> '/Users/blah/pathToProject/web/src/pages/ExamplePage'
 */
const getPathRelativeToSrc = maybeAbsolutePath => {
  // If the path is already relative
  if (!_path.default.isAbsolute(maybeAbsolutePath)) {
    return maybeAbsolutePath;
  }
  return `./${_path.default.relative((0, _projectConfig.getPaths)().web.src, maybeAbsolutePath)}`;
};
const withRelativeImports = page => {
  return {
    ...page,
    relativeImport: (0, _projectConfig.ensurePosixPath)(getPathRelativeToSrc(page.importPath))
  };
};
function _default({
  types: t
}, {
  prerender = false,
  vite = false
}) {
  var _context;
  // @NOTE: This var gets mutated inside the visitors
  let pages = (0, _map.default)(_context = (0, _projectConfig.processPagesDir)()).call(_context, withRelativeImports);
  return {
    name: 'babel-plugin-redwood-routes-auto-loader',
    visitor: {
      // Remove any pages that have been explicitly imported in the Routes file,
      // because when one is present, the user is requesting that the module be
      // included in the main bundle.
      ImportDeclaration(p) {
        var _context2;
        if (pages.length === 0) {
          return;
        }
        const userImportRelativePath = getPathRelativeToSrc((0, _projectConfig.importStatementPath)(p.node.source?.value));
        const defaultSpecifier = (0, _filter.default)(_context2 = p.node.specifiers).call(_context2, specifiers => t.isImportDefaultSpecifier(specifiers))[0];

        // Remove Page imports in prerender mode (see babel-preset)
        // The removed imports will be replaced further down in this file
        // with declarations like these:
        // const HomePage = {
        //   name: "HomePage",
        //   loader: () => import("./pages/HomePage/HomePage")
        //   prerenderLoader: () => require("./pages/HomePage/HomePage")
        // };
        // This is to make sure that all the imported "Page modules" are normal
        // imports and not asynchronous ones.
        // Note that jest in a user's project does not enter this block, but our tests do
        if (prerender) {
          // Match import paths, const name could be different

          const pageThatUserImported = (0, _find.default)(pages).call(pages, page => {
            return page.relativeImport === (0, _projectConfig.ensurePosixPath)(userImportRelativePath);
          });
          if (pageThatUserImported) {
            var _context3;
            // Update the import name, with the user's import name
            // So that the JSX name stays consistent
            pageThatUserImported.importName = defaultSpecifier.local.name;

            // Remove the default import for the page and leave all the others
            p.node.specifiers = (0, _filter.default)(_context3 = p.node.specifiers).call(_context3, specifier => !t.isImportDefaultSpecifier(specifier));
          }
          return;
        }
        if (userImportRelativePath && defaultSpecifier) {
          // Remove the page from pages list, if it is already explicitly imported, so that we don't add loaders for these pages.
          // We use the path & defaultSpecifier because the const name could be anything
          pages = (0, _filter.default)(pages).call(pages, page => !(page.relativeImport === (0, _projectConfig.ensurePosixPath)(userImportRelativePath)));
        }
      },
      Program: {
        enter() {
          var _context4;
          pages = (0, _map.default)(_context4 = (0, _projectConfig.processPagesDir)()).call(_context4, withRelativeImports);
        },
        exit(p) {
          if (pages.length === 0) {
            return;
          }
          const nodes = [];
          // Prepend all imports to the top of the file
          for (const {
            importName,
            relativeImport
          } of pages) {
            // + const <importName> = {
            //     name: <importName>,
            //     loader: () => import(/* webpackChunkName: "<importName>" */ <relativeImportPath>)
            //     prerenderLoader: (name) => prerenderLoaderImpl
            //   }

            const importArgument = t.stringLiteral(relativeImport);
            importArgument.leadingComments = [{
              type: 'CommentBlock',
              value: ` webpackChunkName: "${importName}" `
            }];
            nodes.push(t.variableDeclaration('const', [t.variableDeclarator(t.identifier(importName), t.objectExpression([t.objectProperty(t.identifier('name'), t.stringLiteral(importName)),
            // loader for dynamic imports (browser)
            // loader: () => import(<importArgument>)
            t.objectProperty(t.identifier('loader'), t.arrowFunctionExpression([], t.callExpression(t.identifier('import'), [importArgument]))),
            // prerenderLoader for ssr/prerender and first load of
            // prerendered pages in browser (csr)
            // prerenderLoader: (name) => { prerenderLoaderImpl }
            t.objectProperty(t.identifier('prerenderLoader'), t.arrowFunctionExpression([t.identifier('name')], prerenderLoaderImpl(prerender, vite, relativeImport, t)))]))]));
          }

          // Insert at the top of the file
          p.node.body.unshift(...nodes);
        }
      }
    }
  };
}
function prerenderLoaderImpl(prerender, vite, relativeImport, t) {
  if (prerender) {
    // This works for both vite and webpack
    return t.callExpression(t.identifier('require'), [t.stringLiteral(relativeImport)]);
  }

  // This code will be output when building the web side (i.e. not when
  // prerendering)
  // active-route-loader will use this code for auto-imported pages, for the
  // first load of a prerendered page
  // Manually imported pages will be bundled in the main bundle and will be
  // loaded by the code in `normalizePage` in util.ts
  let implForBuild;
  if (vite) {
    implForBuild = t.objectExpression([t.objectProperty(t.identifier('default'), t.memberExpression(t.identifier('globalThis.__REDWOOD__PRERENDER_PAGES'), t.identifier('name'), true))]);
  } else {
    // Use __webpack_require__ otherwise all pages will be bundled
    implForBuild = t.callExpression(t.identifier('__webpack_require__'), [t.callExpression(t.identifier('require.resolveWeak'), [t.stringLiteral(relativeImport)])]);
  }
  return implForBuild;
}